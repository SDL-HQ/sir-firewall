name: SIR Real Governance Audit

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'proofs/**'
      - 'docs/**'
      - 'policy/isc_policy.signed.json'
  workflow_dispatch:

jobs:
  audit-and-sign:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SIR_AUDIT_PUSH_TOKEN }}
          fetch-depth: 0

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Clean install SIR Firewall (NO CACHE)
        run: |
          python -m pip install --upgrade pip
          pip uninstall -y sir-firewall sir_firewall || true
          pip install --no-cache-dir --force-reinstall -e .
          python -c "import sir_firewall.core as c; print('LOADED FROM →', c.__file__); print('USE_SEMANTIC_CHECK IS →', c.USE_SEMANTIC_CHECK)"

      - name: Validate domain pack (suite CSV) schema (P7 hygiene)
        env:
          SIR_SUITE_PATH: tests/domain_packs/generic_safety.csv
        run: |
          echo "Validating suite CSV schema: $SIR_SUITE_PATH"
          python tools/validate_domain_pack.py --file "$SIR_SUITE_PATH"

      - name: Run suite through SIR (firewall-only, no live model calls)
        env:
          # Context only (SIR does not call the model in this workflow)
          LITELLM_MODEL: xai/grok-3-beta
          SIR_PROVIDER: xai

          # Suite selection (P3 packs)
          SIR_SUITE_PATH: tests/domain_packs/generic_safety.csv

          # Template selection
          SIR_TEMPLATE_ID: "EU-AI-Act-ISC-v1"
        run: |
          echo "Context model label: $LITELLM_MODEL"
          echo "SIR_PROVIDER: $SIR_PROVIDER"
          echo "SIR_SUITE_PATH: $SIR_SUITE_PATH"
          echo "SIR_TEMPLATE_ID: $SIR_TEMPLATE_ID"
          python red_team_suite.py --suite "$SIR_SUITE_PATH" --no-model-calls

      - name: Compute audit verdict (PASS/FAIL) from counters
        if: always()
        run: |
          leaks="$(cat leaks_count.txt 2>/dev/null || echo 0)"
          harmless="$(cat harmless_blocked.txt 2>/dev/null || echo 0)"

          echo "LEAKS=$leaks" >> "$GITHUB_ENV"
          echo "HARMLESS_BLOCKED=$harmless" >> "$GITHUB_ENV"

          if [ "$leaks" -eq 0 ] && [ "$harmless" -eq 0 ]; then
            echo "AUDIT_PASS=true" >> "$GITHUB_ENV"
            echo "AUDIT_PASS=true (leaks=$leaks harmless_blocked=$harmless)"
          else
            echo "AUDIT_PASS=false" >> "$GITHUB_ENV"
            echo "AUDIT_PASS=false (leaks=$leaks harmless_blocked=$harmless)"
          fi

      - name: Verify ITGL ledger hash chain and export ITGL_FINAL_HASH
        if: always()
        run: |
          python tools/verify_itgl.py | tee itgl_env.txt

          if grep '^ITGL_FINAL_HASH=' itgl_env.txt >> "$GITHUB_ENV"; then
            echo "ITGL_FINAL_HASH exported to GITHUB_ENV"
          else
            echo "WARNING: ITGL_FINAL_HASH not found in verify_itgl output"
          fi

      - name: Sign ISC policy file
        if: always()
        env:
          SDL_PRIVATE_KEY_PEM: ${{ secrets.SDL_PRIVATE_KEY_PEM }}
        run: |
          python tools/sign_policy.py

      - name: Generate signed certificate + HTML
        if: always()
        env:
          SDL_PRIVATE_KEY_PEM: ${{ secrets.SDL_PRIVATE_KEY_PEM }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python tools/generate_certificate.py

      - name: Verify certificate signature
        if: always()
        run: |
          python tools/verify_certificate.py proofs/latest-audit.json

      - name: Archive this run (P6 truth-preserving per-run archive)
        if: always()
        run: |
          python tools/publish_run.py \
            --cert proofs/latest-audit.json \
            --copy proofs/itgl_ledger.jsonl \
            --copy proofs/itgl_final_hash.txt \
            --copy proofs/latest-attempts.log \
            --copy proofs/run_summary.json \
            --copy itgl_env.txt \
            --copy leaks_count.txt \
            --copy harmless_blocked.txt

      - name: Prepare docs/ for GitHub Pages
        if: always()
        run: |
          mkdir -p docs
          touch docs/.nojekyll

      # Always publish per-run archive + index.
      - name: Publish run archive to docs/runs (PASS or FAIL)
        if: always()
        run: |
          rm -rf docs/runs || true
          cp -R proofs/runs docs/runs

      # Publish latest PASS proof to docs/ (PASS only)
      - name: Publish latest PASS proof to docs/ (PASS only)
        if: always() && env.AUDIT_PASS == 'true'
        run: |
          cp -f proofs/latest-audit.html docs/latest-audit.html
          cp -f proofs/latest-audit.json docs/latest-audit.json

      # Publish latest run status marker ALWAYS (PASS / FAIL / INCONCLUSIVE)
      - name: Publish latest run marker to docs/ (always)
        if: always()
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          stamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          leaks="$(cat leaks_count.txt 2>/dev/null || echo 0)"
          harmless="$(cat harmless_blocked.txt 2>/dev/null || echo 0)"

          inconclusive="false"

          # Mark INCONCLUSIVE if critical artifacts are missing or integrity checks did not produce expected signals.
          if [ ! -f "proofs/latest-audit.json" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/latest-audit.html" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/run_summary.json" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/itgl_final_hash.txt" ]; then inconclusive="true"; fi
          if ! grep -q '^ITGL_FINAL_HASH=' itgl_env.txt 2>/dev/null; then inconclusive="true"; fi

          status="FAIL"
          if [ "$inconclusive" = "true" ]; then
            status="INCONCLUSIVE"
          else
            if [ "$AUDIT_PASS" = "true" ]; then
              status="PASS"
            else
              status="FAIL"
            fi
          fi

          cat > docs/latest-run.json <<EOF
          {
            "status": "${status}",
            "audit_pass": ${AUDIT_PASS},
            "inconclusive": ${inconclusive},
            "leaks": ${leaks},
            "harmless_blocked": ${harmless},
            "run_id": "${GITHUB_RUN_ID}",
            "sha": "${GITHUB_SHA}",
            "repository": "${GITHUB_REPOSITORY}",
            "timestamp_utc": "${stamp}"
          }
          EOF

          echo "Wrote docs/latest-run.json:"
          cat docs/latest-run.json

      - name: Upload proof artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: SIR-Audit-Proof
          path: |
            proofs/
            docs/
            policy/isc_policy.json
            policy/isc_policy.signed.json
            leaks_count.txt
            harmless_blocked.txt
            itgl_env.txt

      # Commit behavior:
      # - Always commit proofs/runs + docs/runs + latest-run marker
      # - Only commit latest-audit + signed policy + latest sidecars if PASS
      - name: Commit proof files back to repo (archive always; latest PASS + sidecars only)
        if: always() && github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail

          git config user.name "SIR Audit Bot"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Retry pull/rebase + push to avoid races with concurrent runs.
          for attempt in 1 2 3; do
            echo "Git sync attempt $attempt/3..."
            git fetch origin main

            # Rebase our work on the latest main. If this fails, retry.
            if ! git pull --rebase origin main; then
              echo "Rebase failed on attempt $attempt. Retrying..."
              git rebase --abort || true
              sleep 2
              continue
            fi

            # Always stage the run archive + index + latest-run marker (PASS or FAIL)
            git add proofs/runs/ docs/runs/ docs/latest-run.json

            # Only stage latest PASS pointers + signed policy + latest sidecars if PASS
            if [ "${AUDIT_PASS}" = "true" ]; then
              git add proofs/latest-audit.json proofs/latest-audit.html || true
              git add docs/latest-audit.json docs/latest-audit.html || true
              git add policy/isc_policy.signed.json || true

              # Keep "latest" proof sidecars coherent in proofs/
              git add proofs/itgl_ledger.jsonl proofs/itgl_final_hash.txt proofs/latest-attempts.log proofs/run_summary.json || true
            fi

            leaks="$(cat leaks_count.txt 2>/dev/null || echo 0)"
            harmless="$(cat harmless_blocked.txt 2>/dev/null || echo 0)"
            stamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

            git commit -m "SIR Proof: ${AUDIT_PASS} | ${leaks} leaks | ${harmless} harmless | ${stamp}" || echo "Nothing to commit"

            if git push; then
              echo "Push succeeded."
              break
            else
              echo "Push failed on attempt $attempt. Retrying..."
              sleep 2
            fi

            if [ "$attempt" -eq 3 ]; then
              echo "ERROR: failed to push proof updates after 3 attempts"
              exit 1
            fi
          done

      - name: Finalize CI status (fail if audit failed or inconclusive)
        if: always()
        run: |
          echo "AUDIT_PASS=$AUDIT_PASS"
          echo "LEAKS=$LEAKS"
          echo "HARMLESS_BLOCKED=$HARMLESS_BLOCKED"

          inconclusive="false"
          if [ ! -f "proofs/latest-audit.json" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/latest-audit.html" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/run_summary.json" ]; then inconclusive="true"; fi
          if [ ! -f "proofs/itgl_final_hash.txt" ]; then inconclusive="true"; fi
          if ! grep -q '^ITGL_FINAL_HASH=' itgl_env.txt 2>/dev/null; then inconclusive="true"; fi

          if [ "$inconclusive" = "true" ]; then
            echo "Audit INCONCLUSIVE — failing CI after preserving proof."
            exit 1
          fi

          if [ "$AUDIT_PASS" != "true" ]; then
            echo "Audit FAILED (leaks=$LEAKS harmless_blocked=$HARMLESS_BLOCKED) — failing CI after preserving proof."
            exit 1
          fi

          echo "Audit PASSED — CI green."
