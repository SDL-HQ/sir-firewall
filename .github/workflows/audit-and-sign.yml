name: SIR Real Governance Audit

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'proofs/**'
      - 'docs/**'
      - 'policy/isc_policy.signed.json'
  workflow_dispatch:

jobs:
  audit-and-sign:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SIR_AUDIT_PUSH_TOKEN }}
          fetch-depth: 0

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Clean install SIR Firewall (NO CACHE)
        run: |
          python -m pip install --upgrade pip
          pip uninstall -y sir-firewall sir_firewall || true
          pip install --no-cache-dir --force-reinstall -e .
          python -c "import sir_firewall.core as c; print('LOADED FROM →', c.__file__); print('USE_SEMANTIC_CHECK IS →', c.USE_SEMANTIC_CHECK)"

      - name: Validate domain pack (suite CSV) schema (P7 hygiene)
        env:
          SIR_SUITE_PATH: tests/domain_packs/generic_safety.csv
        run: |
          echo "Validating suite CSV schema: $SIR_SUITE_PATH"
          python tools/validate_domain_pack.py --file "$SIR_SUITE_PATH"

      - name: Run suite through SIR (firewall-only, no live model calls)
        env:
          # Context only (SIR does not call the model in this workflow)
          LITELLM_MODEL: xai/grok-3-beta
          SIR_PROVIDER: xai

          # Suite selection (P3 packs)
          SIR_SUITE_PATH: tests/domain_packs/generic_safety.csv

          # Template selection
          SIR_TEMPLATE_ID: "EU-AI-Act-ISC-v1"
        run: |
          echo "Context model label: $LITELLM_MODEL"
          echo "SIR_PROVIDER: $SIR_PROVIDER"
          echo "SIR_SUITE_PATH: $SIR_SUITE_PATH"
          echo "SIR_TEMPLATE_ID: $SIR_TEMPLATE_ID"
          python red_team_suite.py --suite "$SIR_SUITE_PATH" --no-model-calls

      - name: Compute audit verdict (PASS/FAIL) from counters
        if: always()
        run: |
          leaks="$(cat leaks_count.txt 2>/dev/null || echo 0)"
          harmless="$(cat harmless_blocked.txt 2>/dev/null || echo 0)"

          echo "LEAKS=$leaks" >> "$GITHUB_ENV"
          echo "HARMLESS_BLOCKED=$harmless" >> "$GITHUB_ENV"

          if [ "$leaks" -eq 0 ] && [ "$harmless" -eq 0 ]; then
            echo "AUDIT_PASS=true" >> "$GITHUB_ENV"
            echo "AUDIT_PASS=true (leaks=$leaks harmless_blocked=$harmless)"
          else
            echo "AUDIT_PASS=false" >> "$GITHUB_ENV"
            echo "AUDIT_PASS=false (leaks=$leaks harmless_blocked=$harmless)"
          fi

      - name: Verify ITGL ledger hash chain and export ITGL_FINAL_HASH
        if: always()
        run: |
          python tools/verify_itgl.py | tee itgl_env.txt

          if grep '^ITGL_FINAL_HASH=' itgl_env.txt >> "$GITHUB_ENV"; then
            echo "ITGL_FINAL_HASH exported to GITHUB_ENV"
          else
            echo "WARNING: ITGL_FINAL_HASH not found in verify_itgl output"
          fi

      - name: Sign ISC policy file
        if: always()
        env:
          SDL_PRIVATE_KEY_PEM: ${{ secrets.SDL_PRIVATE_KEY_PEM }}
        run: |
          python tools/sign_policy.py

      - name: Generate signed certificate + HTML
        if: always()
        env:
          SDL_PRIVATE_KEY_PEM: ${{ secrets.SDL_PRIVATE_KEY_PEM }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python tools/generate_certificate.py

      - name: Verify certificate signature
        if: always()
        run: |
          python tools/verify_certificate.py proofs/latest-audit.json

      - name: Archive this run (P6 truth-preserving per-run archive)
        if: always()
        run: |
          python tools/publish_run.py \
            --cert proofs/latest-audit.json \
            --copy proofs/itgl_ledger.jsonl \
            --copy proofs/itgl_final_hash.txt \
            --copy proofs/latest-attempts.log \
            --copy proofs/run_summary.json \
            --copy itgl_env.txt \
            --copy leaks_count.txt \
            --copy harmless_blocked.txt

      - name: Prepare docs/ for GitHub Pages
        if: always()
        run: |
          mkdir -p docs
          touch docs/.nojekyll

      # Option A:
      # - Publish per-run archive + index ALWAYS
      # - Publish latest-audit ONLY if PASS (so latest-audit stays "latest passing audit")
      - name: Publish run archive to docs/runs (PASS or FAIL)
        if: always()
        run: |
          rm -rf docs/runs || true
          cp -R proofs/runs docs/runs

      - name: Publish latest PASS proof to docs/ (PASS only)
        if: always() && env.AUDIT_PASS == 'true'
        run: |
          cp -f proofs/latest-audit.html docs/latest-audit.html
          cp -f proofs/latest-audit.json docs/latest-audit.json

      - name: Upload proof artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: SIR-Audit-Proof
          path: |
            proofs/
            docs/
            policy/isc_policy.json
            policy/isc_policy.signed.json
            leaks_count.txt
            harmless_blocked.txt
            itgl_env.txt

      # Commit behavior (Option A):
      # - Always commit proofs/runs + docs/runs (truth-preserving archive, failures included)
      # - Only commit latest-audit + signed policy if PASS
      - name: Commit proof files back to repo (archive always; latest PASS only)
        if: always() && github.ref == 'refs/heads/main'
        run: |
          git config user.name "SIR Audit Bot"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Always stage the run archive + index (PASS or FAIL)
          git add proofs/runs/ docs/runs/

          # Only stage latest PASS pointers + signed policy if PASS
          if [ "$AUDIT_PASS" = "true" ]; then
            git add proofs/latest-audit.json proofs/latest-audit.html || true
            git add docs/latest-audit.json docs/latest-audit.html || true
            git add policy/isc_policy.signed.json || true
          fi

          leaks="$(cat leaks_count.txt 2>/dev/null || echo 0)"
          harmless="$(cat harmless_blocked.txt 2>/dev/null || echo 0)"
          stamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          git commit -m "SIR Proof: $AUDIT_PASS | $leaks leaks | $harmless harmless | $stamp" || echo "Nothing to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.SIR_AUDIT_PUSH_TOKEN }}

      - name: Finalize CI status (fail if audit failed)
        if: always()
        run: |
          echo "AUDIT_PASS=$AUDIT_PASS"
          echo "LEAKS=$LEAKS"
          echo "HARMLESS_BLOCKED=$HARMLESS_BLOCKED"

          if [ "$AUDIT_PASS" != "true" ]; then
            echo "Audit FAILED (leaks=$LEAKS harmless_blocked=$HARMLESS_BLOCKED) — failing CI after preserving proof."
            exit 1
          fi

          echo "Audit PASSED — CI green."
